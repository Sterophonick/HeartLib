/*
** Adpcm - Sources\Commun\Adpcm\Decoder\Adpcm.c
** Nicolas ROBERT [NRX] - Hong Kong 2005
*/

////////////////
// Inclusions //
////////////////
#include "libheart.h"
extern gba_system __hrt_system;

////////////
// Macros //
////////////
#define FIFO ((volatile unsigned long*)0x040000A0)
#define DMA  ((volatile DMA_STRUCT*)0x040000BC)
#define TM   ((volatile TM_STRUCT*)0x04000100)

#define SOUNDCNT_L *(volatile unsigned short*)0x04000080
#define SOUNDCNT_H *(volatile unsigned short*)0x04000082
#define SOUNDCNT_X *(volatile unsigned short*)0x04000084

#define FREQUENCY_SYSTEM_CLOCK 16777216
#define FREQUENCY_VBLANK_1024  61161  // = 59.7275*1024
#define FREQUENCY_RATIO        280896 // = 16777216/59.7275
#define MAX_WAVE_FREQUENCY     22050
#define MAX_NUMBER_SAMPLES     (MAX_WAVE_FREQUENCY*1024/FREQUENCY_VBLANK_1024)

///////////
// Types //
///////////
typedef struct
{
   unsigned long SAD;
   unsigned long DAD;
   unsigned short CNT_L;
   unsigned short CNT_H;
}
DMA_STRUCT;

typedef struct
{
   unsigned short CNT_L;
   unsigned short CNT_H;
}
TM_STRUCT;

typedef struct
{
   const unsigned char* start;
   const unsigned char* stop;
   const unsigned char* inputData;
   unsigned char noCompress;
   signed char repeat;
   unsigned short numberSamplesPerVbl;

   signed char __attribute__ ((aligned(4))) outputData[2][(MAX_NUMBER_SAMPLES+8)&~15]; // It must be a multiple of 4*4 bytes
   signed long lastSample;
   signed short lastIndex;
   unsigned char outputBuffer;
}
Channel;

typedef struct
{
   unsigned char numberChannels;
   Channel* channel[2];
}
Adpcm;

////////////////////////
// Variables globales //
////////////////////////
Adpcm adpcm={0,{NULL,NULL}};

const signed char adpcmModifyIndex[16]=
{
   -1,-1,-1,-1,2,4,6,8,
   -1,-1,-1,-1,2,4,6,8
};

const signed short adpcmStep[89]=
{
       7,    8,    9,   10,   11,   12,   13,   14,   16,
      17,   19,   21,   23,   25,   28,   31,   34,   37,
      41,   45,   50,   55,   60,   66,   73,   80,   88,
      97,  107,  118,  130,  143,  157,  173,  190,  209,
     230,  253,  279,  307,  337,  371,  408,  449,  494,
     544,  598,  658,  724,  796,  876,  963, 1060, 1166,
    1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749,
    3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,
    7132, 7845, 8630, 9493,10442,11487,12635,13899,15289,
   16818,18500,20350,22385,24623,27086,29794,32767
};

//////////////////////
// AdpcmSafeStopDma //
//////////////////////
inline void AdpcmSafeStopDma(volatile DMA_STRUCT* dma)
{
	if (__hrt_system.hrt_start == 1)
	{
		// Is the DMA currently enabled?
		if (dma->CNT_H&(1 << 15))
		{
			// Is the "DMA Repeat" currently "ON"?
			if (dma->CNT_H&(1 << 9))
			{
				// We must first apply the following settings to avoid problems
				dma->CNT_H = (1 << 15) | // DMA Enable Flag = ON
					(0 << 12) | // DMA Start Timing Setting #0 => Start Immediately
					(1 << 10) | // DMA Transfer Type = 32-bit Transfer
					(0 << 9) |  // DMA Repeat = OFF
					(0 << 7) |  // Source Address Control Flag Setting #0 => Increment after Transfer
					(2 << 5);  // Destination Address Control Flag Setting #2 => Fixed

		 // Wait a little bit before setting the DMA again
				asm volatile("nop\nnop\nnop\nnop"); // Delay of 4 clocks
			}

			// Disable the DMA
			dma->CNT_H = (0 << 15) | // DMA Enable Flag = OFF
				(0 << 12) | // DMA Start Timing Setting #0 => Start Immediately
				(1 << 10) | // DMA Transfer Type = 32-bit Transfer
				(0 << 9) |  // DMA Repeat = OFF
				(0 << 7) |  // Source Address Control Flag Setting #0 => Increment after Transfer
				(2 << 5);  // Destination Address Control Flag Setting #2 => Fixed
		}
	}
}

/////////////////////
// AdpcmSafeSetDma //
/////////////////////
inline void AdpcmSafeSetDma(volatile DMA_STRUCT* dma, unsigned long sourceAddress)
{
	if (__hrt_system.hrt_start == 1)
	{
		// First, safely stop the DMA
		AdpcmSafeStopDma(dma);

		// Wait a little bit before setting the DMA again
		asm volatile("nop\nnop\nnop\nnop"); // Delay of 4 clocks

		// Set the new parameters
		dma->SAD = sourceAddress;
		dma->CNT_H = (1 << 15) | // DMA Enable Flag = ON
			(3 << 12) | // DMA Startup Timing Setting #3 => Start When Request Generated by Direct-Sound FIFO
			(1 << 10) | // DMA Transfer Type = 32-bit Transfer
			(1 << 9) |  // DMA Repeat = ON (because of direct-sound FIFO transfer mode)
			(0 << 7) |  // Source Address Control Flag Setting #0 => Increment after Transfer
			(2 << 5);  // Destination Address Control Flag Setting #2 => Fixed
	}
}

///////////////
// AdpcmInit //
///////////////
unsigned char hrt_InitADPCM(unsigned char numberChannels)
{
	if (__hrt_system.hrt_start == 1)
	{
		unsigned char channel;

		// Check the number of requested channels is correct
		if ((numberChannels != 1 && numberChannels != 2) || adpcm.numberChannels != 0)
			return(1);
		adpcm.numberChannels = numberChannels;

		// Enable the sound processing (direct sound A & B)
		SOUNDCNT_X = (1 << 7);  // All Sounds Operation Flag = Operate
		SOUNDCNT_L = 0;       // Disable sounds 1~4...
		SOUNDCNT_H = (1 << 2) |  // Output Ratio for Direct Sound A = Full Range
			(1 << 3) |  // Output Ratio for Direct Sound B = Full Range
			(1 << 8) |  // R Output of Direct Sound A = Output to R
			(1 << 9) |  // L Output of Direct Sound A = Output to L
			(0 << 10) | // Timer Selection for Direct Sound A = Timer 0
			(1 << 11) | // Direct Sound FIFO A Clear and Sequencer Reset
			(1 << 12) | // R Output of Direct Sound B = Output to R
			(1 << 13) | // L Output of Direct Sound B = Output to L
			(1 << 14) | // Timer Selection for Direct Sound B = Timer 1
			(1 << 15); // Direct Sound FIFO B Clear and Sequencer Reset

 // Prepare the DMA and allocate the memory
		for (channel = 0; channel < numberChannels; ++channel)
		{
			DMA[channel].DAD = (unsigned long)&FIFO[channel];
			DMA[channel].CNT_L = 4; // Word Count = 4, to later safely stop the DMA

			adpcm.channel[channel] = (Channel*)malloc(sizeof(Channel));
		}

		// It looks ok!
		return(0);
	}
	return 0;
}

//////////////////
// AdpcmDestroy //
//////////////////
void hrt_DestoryADPCM(void)
{
	if (__hrt_system.hrt_start == 1)
	{
		unsigned char channel;

		// Really disable the sound processing
		SOUNDCNT_X = (0 << 7); // All Sounds Operation Flag = Halt

		// Stop the sound of each channel immediately, and free the memory allocated
		for (channel = 0; channel < adpcm.numberChannels; ++channel)
		{
			AdpcmSafeStopDma(&DMA[channel]);
			TM[channel].CNT_H = (0 << 7); // Timer Operation Flag = Disable
			free(adpcm.channel[channel]);
		}
	}
}

////////////////
// AdpcmStart //
////////////////
unsigned char hrt_StartADPCM(const Sound* sound, signed char repeat, unsigned char channel)
{
	if (__hrt_system.hrt_start == 1)
	{
		Channel* channelPointer;
		unsigned short numberSamplesPerVbl;
		unsigned short timerDuration;

		// Check the channel and the sample rate
		if (channel >= adpcm.numberChannels || (!sound->noCompress && sound->sampleRate > MAX_WAVE_FREQUENCY))
			return(1);
		channelPointer = adpcm.channel[channel];

		// Reset the "repeat" now to avoid problems if the VBL occurs during the following instructions
		channelPointer->repeat = 0;

		// Stop any sound currently playing on this channel
		AdpcmSafeStopDma(&DMA[channel]);
		TM[channel].CNT_H = (0 << 7); // Timer Operation Flag = Disable

		// Compute the number of samples per VBL and the duration of the timer
		numberSamplesPerVbl = (((sound->sampleRate << 10) / FREQUENCY_VBLANK_1024) + 8)&~15; // It must be a multiple of 4*4 bytes
		timerDuration = FREQUENCY_RATIO / numberSamplesPerVbl;

		// Initialize the Adpcm structure
		channelPointer->start = sound->data;
		channelPointer->stop = sound->data + sound->length;
		channelPointer->inputData = sound->data;
		channelPointer->noCompress = sound->noCompress;
		channelPointer->numberSamplesPerVbl = numberSamplesPerVbl;

		if (!sound->noCompress)
		{
			channelPointer->lastSample = 0;
			channelPointer->lastIndex = 0;
			channelPointer->outputBuffer = 0;
		}

		// Prepare the timer
		TM[channel].CNT_L = 65535 - timerDuration; // Timer Setting (timer overflow) => we get the wave file frequency

		// Set the "repeat" so that the sound will be activated during the next VBL
		channelPointer->repeat = repeat;

		// It looks ok!
		return(0);
	}
	return 0;
}

///////////////
// AdpcmStop //
///////////////
unsigned char hrt_StopADPCM(unsigned char channel)
{
	if (__hrt_system.hrt_start == 1)
	{
		// Check the channel
		if (channel >= adpcm.numberChannels)
			return(1);

		// Stop the sound (it will actually be stopped during the next VBL)
		adpcm.channel[channel]->repeat = 0;
		return(0);
	}
	return 0;
}

/////////////////
// AdpcmStatus //
/////////////////
signed char hrt_GetADPCMStatus(unsigned char channel)
{
	if (__hrt_system.hrt_start == 1)
	{
		// Check the channel
		if (channel >= adpcm.numberChannels)
			return(0);

		// Return the current value of "repeat" for this channel
		return(adpcm.channel[channel]->repeat);
	}
	return 0;
}

////////////////////
// AdpcmDecodeVbl //
////////////////////
void __attribute__((section(".iwram"), long_call)) hrt_ADPCMDecodeVBL(unsigned char channel)
{
	if (__hrt_system.hrt_start == 1)
	{
		Channel* channelPointer;
		const unsigned char* inputData;
		signed char* outputData;
		signed long sample;
		signed short index;
		signed short step;
		unsigned char byte;
		unsigned char code;
		signed short diff;
		unsigned short counter;

		// Check the channel
		if (channel >= adpcm.numberChannels)
			return;
		channelPointer = adpcm.channel[channel];

		// Anything to do?
		if (!channelPointer->repeat)
		{
			// No sound...
			AdpcmSafeStopDma(&DMA[channel]);
			TM[channel].CNT_H = (0 << 7); // Timer Operation Flag = Disable
			return;
		}

		// Is it a simple (uncompressed) wave file?
		if (channelPointer->noCompress)
		{
			// Is it the beginning of the sound?
			if (channelPointer->inputData == channelPointer->start)
				code = 1;
			else
				code = 0;

			// Or maybe its end?
			channelPointer->inputData += channelPointer->numberSamplesPerVbl;
			if (channelPointer->inputData >= channelPointer->stop)
			{
				if (channelPointer->repeat == -1 || --channelPointer->repeat)
				{
					// Prepare to restart the sound
					channelPointer->inputData = channelPointer->start;
					code = 1;
				}
				else
				{
					// Stop it now (we cannot wait for the next VBL!)
					AdpcmSafeStopDma(&DMA[channel]);
					TM[channel].CNT_H = (0 << 7); // Timer Operation Flag = Disable
					return;
				}
			}

			// Start the sound
			if (code)
			{
				// Set the DMA
				AdpcmSafeSetDma(&DMA[channel], (unsigned long)channelPointer->start);

				// Enable the timer
				TM[channel].CNT_H = (0 << 0) | // Prescalar Selection Setting #0 => System clock (16.78MHz)
					(1 << 7); // Timer Operation Flag = Enable
			}
			return;
		}

		// Retrieve the previous data
		inputData = channelPointer->inputData;
		sample = channelPointer->lastSample;
		index = channelPointer->lastIndex;

		// Here is the pointer to the output buffer
		outputData = channelPointer->outputData[channelPointer->outputBuffer];

		// Process the samples
		byte = 0;
		for (counter = channelPointer->numberSamplesPerVbl; counter; --counter)
		{
			// Get the code
			if (counter & 1)
			{
				code = byte >> 4;

				// Check if it's finished
				if (inputData >= channelPointer->stop)
				{
					if (channelPointer->repeat == -1 || --channelPointer->repeat)
					{
						// We go back to the beginning
						inputData = channelPointer->start;
						sample = 0;
						index = 0;
					}
					else
					{
						// Decoding is finished; we fill the end of the output buffer with 0...
						while (counter--)
							*outputData++ = 0;
						break;
					}
				}
			}
			else
			{
				byte = *inputData++;
				code = byte & 0x0F;
			}

			// Get the step
			step = adpcmStep[index];

			// Modify the existing sample
			diff = step >> 3;
			if (code & 1)
				diff += step >> 2;
			if (code & 2)
				diff += step >> 1;
			if (code & 4)
				diff += step;
			if (code & 8)
			{
				sample -= diff;
				if (sample < -32768)
					sample = -32768;
			}
			else
			{
				sample += diff;
				if (sample > 32767)
					sample = 32767;
			}

			// Compute the next index
			index += adpcmModifyIndex[code];
			if (index < 0)
				index = 0;
			else if (index > 88)
				index = 88;

			// Store the new sample (8 bits only, it's just a GBA!)
			*outputData++ = sample >> 8;
		}

		// Store the current data
		channelPointer->inputData = inputData;
		channelPointer->lastSample = sample;
		channelPointer->lastIndex = index;

		// Set the DMA
		AdpcmSafeSetDma(&DMA[channel], (unsigned long)channelPointer->outputData[channelPointer->outputBuffer]);

		// Enable the timer (even if it has already been enabled ;-)
		TM[channel].CNT_H = (0 << 0) | // Prescalar Selection Setting #0 => System clock (16.78MHz)
			(1 << 7); // Timer Operation Flag = Enable

// Swap the output buffers
		channelPointer->outputBuffer ^= 1;
	}
}
